#define TSMP_IMPL
#include "TSMaster.h"
#include "MPLibrary.h"
#include "Database.h"
#include "Test.h"

// Global definitions
/*------------------------------------------------------------------------------
| File:
|   xlDAIOexample.c
| Project:
|   IOcab/IOpiggy Test Application ()
|   Example application using 'vxlapi.dll'
|-------------------------------------------------------------------------------
| $Author: visssi $    $Locker: $   $Revision: 99113 $
|-------------------------------------------------------------------------------
| Copyright (c) 2014 by Vector Informatik GmbH.  All rights reserved.
 -----------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// includes
//
#include <windows.h>
#include <stdio.h>
#include <conio.h>

/*import vxlapi.h*/
#include "C:\Users\jchen57\Documents\TSMaster_Porjects\N822_NM_Auto_Test\bin\vxlapi.h"
/*
Import vxlapi_bcc.lib

TSMaster uses bcc(Borland C++ Compiler) to build source codes.
vxlapi.lib provided by Vector is generated by VC++.
It can not be recognized by bcc.
Using coff2omf.exe provided by coff2omf to covert VC lib to bcc lib:
1.cd path(the root folder of coff2omf.exe) 
2.coff2omf.exe -lib:ms c:/temp/bin/vxlapi.lib bcb c:/temp/bin/vxlapi_bcc.lib
*/
#pragma comment(lib, "C:\Users\jchen57\Documents\TSMaster_Porjects\N822_NM_Auto_Test\bin\vxlapi_bcc.lib")

/*Original Vector key input handle are replaced by TSMaster key event*/
s32 c = 0;
int stop = 0;

/////////////////////////////////////////////////////////////////////////////
// const
//

// analog lines
const unsigned int AIO0 = 0x01;
const unsigned int AIO1 = 0x02;
const unsigned int AIO2 = 0x04;
const unsigned int AIO3 = 0x08;
const unsigned int AIO_ALL = 0x0F;

// digital lines
const unsigned int DIO0 = 0x01;
const unsigned int DIO1 = 0x02;
const unsigned int DIO2 = 0x04;
const unsigned int DIO3 = 0x08;
const unsigned int DIO4 = 0x10;
const unsigned int DIO5 = 0x20;
const unsigned int DIO6 = 0x40;
const unsigned int DIO7 = 0x80;
const unsigned int DIO_ALL = 0xFF;

// combined digital lines for output mask
const unsigned int OUTPUT_DIO0_DIO01 = 0x03;
const unsigned int OUTPUT_DIO2_DIO03 = 0x0C;
const unsigned int OUTPUT_DIO4_DIO05 = 0x30;
const unsigned int OUTPUT_DIO6_DIO07 = 0xC0;

// masks for switches
const unsigned int SWITCH_DIO0_DIO01 = 0x01;
const unsigned int SWITCH_DIO2_DIO03 = 0x02;
const unsigned int SWITCH_DIO4_DIO05 = 0x04;
const unsigned int SWITCH_DIO6_DIO07 = 0x08;

/////////////////////////////////////////////////////////////////////////////
// globals
// Driver Variables

char g_AppName[XL_MAX_LENGTH + 1] = "xlDAIOexample"; // Application name which is displayed in VHWconf
XLportHandle g_xlPortHandle = XL_INVALID_PORTHANDLE; // Global porthandle (we use only one!)
XLdriverConfig g_xlDrvConfig;						 // Contains the actual hardware configuration
XLaccess g_xlChannelMask = 0;						 // Global channelmask (includes all founded channels)
XLaccess g_xlPermissionMask;						 // Global permissionmask (includes all founded channels)
unsigned short g_trcvType;							 // Transceiver type on DAIO channel

// Thread and Event Variables
HANDLE g_Thread;				   // Flag to start/stop the RX thread
XLhandle g_hMsgEvent;			   // Notification handle for the receive queue
int g_ThreadRun = 1;			   // controls RX thread
int g_ioPiggyDigitalTriggerCyclic; // Cyclic or on-edge digital trigger

// Measuring Variables
unsigned int g_frequency = 1000;
unsigned int g_outputMilliVolt = 4096;
unsigned int g_switchState = 0; // On IO-Cab: 0 = relay open, 1 = relay closed

////////////////////////////////////////////////////////////////////////////
// defines
#define RECEIVE_EVENT_COUNT 1
#define drawLine "-------------------------------------------------------------------\n"

////////////////////////////////////////////////////////////////////////////
// functions (prototypes)
XLstatus daioInit();
XLstatus daioCreateRxThread(void);
XLstatus daioSetupCab(void);
XLstatus daioSetupFixPiggy(void);
XLstatus daioSetupPiggy(void);
void CloseExample();
DWORD WINAPI RxThread(LPVOID par);

////////////////////////////////////////////////////////////////////////////

//! daioInit

//!
//!
////////////////////////////////////////////////////////////////////////////

XLstatus daioInit()
{

	unsigned int hwType = 0;
	unsigned int hwIndex = 0;	// Index of the hardware for the same hardware type
	unsigned int hwChannel = 0; // Index of the channel on the same hardware.
	unsigned int foundHw = 0;
	XLstatus xlStatus = XL_ERROR;
	unsigned int i;
	unsigned int ci;
	char callSign;

	printf("\nDRIVER INITIALIZATION\n%s", drawLine);

	// Open Driver
	xlStatus = xlOpenDriver();
	if (xlStatus)
	{
		printf("\nERROR: xlOpenDriver failed!\n");
		return xlStatus;
	}
	printf(" >> XL Driver Opened.\n");

	// Read driver config
	xlStatus = xlGetDriverConfig(&g_xlDrvConfig);
	if (xlStatus)
	{
		printf("\nERROR: xlGetDriverConfig failed!\n");
		return xlStatus;
	}

	// Searching for a DAIO channel...
	xlStatus = xlGetApplConfig(g_AppName,  // name of application's channel
							   0,		   // zero based application channel
							   &hwType,	   // received type of hardware
							   &hwIndex,   // received hardware index
							   &hwChannel, // received hardware channel
							   XL_BUS_TYPE_DAIO);

	if (xlStatus != XL_SUCCESS)
	{

		for (i = 0; i < g_xlDrvConfig.channelCount; i++)
		{

			// search a channel which supports DAIO
			if (g_xlDrvConfig.channel[i].channelBusCapabilities & XL_BUS_ACTIVE_CAP_DAIO)
			{

				hwType = g_xlDrvConfig.channel[i].hwType;
				hwChannel = g_xlDrvConfig.channel[i].hwChannel;
				hwIndex = g_xlDrvConfig.channel[i].hwIndex;
				printf(" >> Found DAIO channel on hWType: %d;\n", hwType);

				xlStatus = xlSetApplConfig( // Registration of Application with default settings
					g_AppName,				// Application Name
					0,						// Application channel 0
					hwType,					// hwType  (CANcardXL...)
					hwIndex,				// Index of hardware (slot) (0,1,...)
					hwChannel,				// Index of channel (connector) (0,1,...)
					XL_BUS_TYPE_DAIO);		// the application is for LIN.

				if (xlStatus)
				{
					printf("\nERROR: xlSetApplConfig failed!\n");
					return xlStatus;
				}
				else
				{
					foundHw = 1;
				}

				break;
			}
		}
	}
	else
	{
		printf(" >> HW found in registry\n");
		foundHw = 1;
	}

	if (!foundHw)
	{
		printf("Error: no channel assignment?!\n");
		return XL_ERROR;
	}

	ci = xlGetChannelIndex(hwType, hwIndex, hwChannel);
	if (ci > XL_CONFIG_MAX_CHANNELS)
	{
		printf("Error: ?!\n");
		return XL_ERROR;
	}

	g_trcvType = g_xlDrvConfig.channel[ci].transceiverType;

	// check the transceivers (until now there is support for the following ones...)
	if ((g_trcvType == XL_TRANSCEIVER_TYPE_DAIO_8444_OPTO) || (g_trcvType == XL_TRANSCEIVER_TYPE_PB_DAIO_8642) || (g_trcvType == XL_TRANSCEIVER_TYPE_DAIO_1021_FIX))
	{

		printf(" >> DAIO cab/piggy found, trcvType: %d\n", g_trcvType);
	}
	else
	{
		printf("Error: Found unknown Piggy 0x%x!\n", g_trcvType);
		return XL_ERROR;
	}

	// Get Channel Mask - Access to one phys. Channel
	g_xlChannelMask = xlGetChannelMask(hwType, hwIndex, hwChannel);
	if (g_xlChannelMask == 0)
	{
		printf("\nERROR: Vector Hardware Configuration not properly set. Check your settings!\n");
		xlPopupHwConfig(&callSign, 0); // open VHwConf
		return XL_ERROR;
	}

	g_xlPermissionMask = g_xlChannelMask;
	printf(" >> Channel Mask Set CM:0x%I64x\n", g_xlChannelMask);

	// Open Port
	if (xlOpenPort(&g_xlPortHandle, g_AppName, g_xlChannelMask, &g_xlPermissionMask, 1024, XL_INTERFACE_VERSION, XL_BUS_TYPE_DAIO) != XL_SUCCESS)
	{
		printf("\nERROR: xlOpenPort failed!\n");
		return XL_ERROR;
	}
	printf(" >> Port Opened. ");

	return xlStatus;
}

////////////////////////////////////////////////////////////////////////////

//! daioCreateRxThread

//! set the notification and creates the thread.
//!
////////////////////////////////////////////////////////////////////////////

XLstatus daioCreateRxThread(void)
{

	XLstatus xlStatus = XL_ERROR;
	DWORD ThreadId = 0;

	if (g_xlPortHandle != XL_INVALID_PORTHANDLE)
	{

		// Send a event for each Msg!!!
		xlStatus = xlSetNotification(g_xlPortHandle, &g_hMsgEvent, 1);
		if (xlStatus != XL_SUCCESS)
		{
			return xlStatus;
		}

		g_Thread = CreateThread(0, 0x1000, RxThread, (LPVOID)0, 0, &ThreadId);
		if (g_Thread == NULL)
		{
			printf("\nERROR: CreateThread failed\n");
			printf("%i\n", GetLastError());
			return XL_ERROR;
		}
	}

	xlStatus = xlResetClock(g_xlPortHandle);

	return xlStatus;
}

////////////////////////////////////////////////////////////////////////////

//! daioSetupCab

//!
//!
////////////////////////////////////////////////////////////////////////////

XLstatus daioSetupCab(void)
{

	XLstatus xlStatus = XL_ERROR;
	unsigned int digitalOutputMask = 0;
	unsigned int digitalInputMask = 0;
	unsigned int analogOutputMask = 0;
	unsigned int analogInputMask = 0;

	// DIO0/DIO1 = Output (0b00000011), DIO2...DIO7 = Input (0b11111100)
	digitalOutputMask = OUTPUT_DIO0_DIO01;
	digitalInputMask = DIO_ALL & (~digitalOutputMask);
	if (xlDAIOSetDigitalParameters(g_xlPortHandle, g_xlChannelMask, digitalInputMask, digitalOutputMask) != XL_SUCCESS)
	{
		printf("\nERROR: xlDAIOSetDigitalParameters failed\n");
		return 0;
	}

	// AIO0 = Output (0b0001), AIO1...AI03 = Input (0b1110)
	analogOutputMask = AIO0;
	analogInputMask = AIO_ALL & (~analogOutputMask);
	if (g_trcvType == XL_TRANSCEIVER_TYPE_DAIO_8444_OPTO)
	{
		// IO-Cab
		if (xlDAIOSetAnalogParameters(g_xlPortHandle, g_xlChannelMask, analogInputMask, analogOutputMask, 0x00) != XL_SUCCESS)
		{
			printf("\nERROR: xlDAIOSetAnalogParameters failed\n");
			return 0;
		}
	}

	// Activate Channel
	xlStatus = xlActivateChannel(g_xlPortHandle, g_xlChannelMask, XL_BUS_TYPE_DAIO, 0);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlActivateChannel failed!\n");
		return xlStatus;
	}
	printf(" >> Channel Activated.\n");

	xlStatus = xlDAIOSetAnalogOutput(g_xlPortHandle, g_xlChannelMask, g_outputMilliVolt, 0, 0, 0);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlDAIOSetAnalogOutput failed\n");
		return xlStatus;
	}

	// IO-Cab
	if (xlDAIOSetMeasurementFrequency(g_xlPortHandle, g_xlChannelMask, g_frequency) != XL_SUCCESS)
	{
		printf("\nERROR: xlDAIOSetMeasurementFrequency failed\n");
		return 0;
	}

	return xlStatus;
}

////////////////////////////////////////////////////////////////////////////

//! daioSetupFixPiggy

//!
//!
////////////////////////////////////////////////////////////////////////////

XLstatus daioSetupFixPiggy(void)
{

	XLdaioTriggerMode trigMode;
	XLstatus xlStatus = XL_ERROR;

	// Set Trigger mode for IO-Piggy
	memset(&trigMode, 0x00, sizeof(trigMode));
	trigMode.portTypeMask = XL_DAIO_PORT_TYPE_MASK_ANALOG;
	if (g_ioPiggyDigitalTriggerCyclic)
	{
		trigMode.portTypeMask |= XL_DAIO_PORT_TYPE_MASK_DIGITAL;
	}
	trigMode.triggerType = XL_DAIO_TRIGGER_TYPE_CYCLIC;
	trigMode.param.cycleTime = g_frequency * 1000;

	xlStatus = xlIoSetTriggerMode(g_xlPortHandle, g_xlChannelMask, &trigMode);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoSetTriggerMode failed\n");
		return 0;
	}

	// Activate Channel
	xlStatus = xlActivateChannel(g_xlPortHandle, g_xlChannelMask, XL_BUS_TYPE_DAIO, 0);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlActivateChannel failed!\n");
		return xlStatus;
	}
	printf(" >> Channel Activated.\n");

	return xlStatus;
} // daioSetupFixPiggy

////////////////////////////////////////////////////////////////////////////

//! daioSetupPiggy

//!
//!
////////////////////////////////////////////////////////////////////////////

XLstatus daioSetupPiggy(void)
{

	XLstatus xlStatus = XL_ERROR;
	XLdaioSetPort portCfg;
	XLdaioTriggerMode trigMode;
	XLdaioAnalogParams anaPar;

	memset(&portCfg, 0x00, sizeof(portCfg));
	portCfg.portType = XL_DAIO_PORT_TYPE_MASK_DIGITAL;
	portCfg.portMask = XL_DAIO_PORT_MASK_DIGITAL_D0 | XL_DAIO_PORT_MASK_DIGITAL_D1 | XL_DAIO_PORT_MASK_DIGITAL_D2 | XL_DAIO_PORT_MASK_DIGITAL_D3 | XL_DAIO_PORT_MASK_DIGITAL_D4 | XL_DAIO_PORT_MASK_DIGITAL_D5 | XL_DAIO_PORT_MASK_DIGITAL_D6 | XL_DAIO_PORT_MASK_DIGITAL_D7;
	portCfg.portFunction[0] = XL_DAIO_PORT_DIGITAL_PUSHPULL;
	portCfg.portFunction[1] = XL_DAIO_PORT_DIGITAL_PUSHPULL;
	portCfg.portFunction[2] = XL_DAIO_PORT_DIGITAL_IN;
	portCfg.portFunction[3] = XL_DAIO_PORT_DIGITAL_IN;
	portCfg.portFunction[4] = XL_DAIO_PORT_DIGITAL_IN;
	portCfg.portFunction[5] = XL_DAIO_PORT_DIGITAL_IN;
	portCfg.portFunction[6] = XL_DAIO_PORT_DIGITAL_IN;
	portCfg.portFunction[7] = XL_DAIO_PORT_DIGITAL_IN;

	xlStatus = xlIoConfigurePorts(g_xlPortHandle, g_xlChannelMask, &portCfg);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoConfigurePorts(digital) failed\n");
		return xlStatus;
	}

	xlStatus = xlIoSetDigOutLevel(g_xlPortHandle, g_xlChannelMask, XL_DAIO_DO_LEVEL_5V);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoSetDigOutLevel(digIn) failed\n");
		return xlStatus;
	}

	xlStatus = xlIoSetDigInThreshold(g_xlPortHandle, g_xlChannelMask, 1000 /*mV*/);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoSetDigInThreshold failed\n");
		return xlStatus;
	}

	memset(&portCfg, 0x00, sizeof(portCfg));
	portCfg.portType = XL_DAIO_PORT_TYPE_MASK_ANALOG;
	portCfg.portMask = XL_DAIO_PORT_MASK_ANALOG_A0 | XL_DAIO_PORT_MASK_ANALOG_A1 | XL_DAIO_PORT_MASK_ANALOG_A2 | XL_DAIO_PORT_MASK_ANALOG_A3;
	portCfg.portFunction[0] = XL_DAIO_PORT_ANALOG_OUT;
	portCfg.portFunction[1] = XL_DAIO_PORT_ANALOG_IN;
	portCfg.portFunction[2] = XL_DAIO_PORT_ANALOG_IN;
	portCfg.portFunction[3] = XL_DAIO_PORT_ANALOG_IN;

	xlStatus = xlIoConfigurePorts(g_xlPortHandle, g_xlChannelMask, &portCfg);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoConfigurePorts(analog) failed\n");
		return xlStatus;
	}

	// Set Trigger mode for IO-Piggy
	memset(&trigMode, 0x00, sizeof(trigMode));
	trigMode.portTypeMask = XL_DAIO_PORT_TYPE_MASK_ANALOG;
	if (g_ioPiggyDigitalTriggerCyclic)
	{
		trigMode.portTypeMask |= XL_DAIO_PORT_TYPE_MASK_DIGITAL;
	}
	trigMode.triggerType = XL_DAIO_TRIGGER_TYPE_CYCLIC;
	trigMode.param.cycleTime = g_frequency * 1000;

	xlStatus = xlIoSetTriggerMode(g_xlPortHandle, g_xlChannelMask, &trigMode);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoSetTriggerMode(cyclic) failed\n");
		return 0;
	}

	if (g_ioPiggyDigitalTriggerCyclic == 0)
	{
		memset(&trigMode, 0x00, sizeof(trigMode));
		trigMode.portTypeMask = XL_DAIO_PORT_TYPE_MASK_DIGITAL;
		trigMode.triggerType = XL_DAIO_TRIGGER_TYPE_PORT;
		trigMode.param.digital.portMask = XL_DAIO_PORT_MASK_DIGITAL_D2 | XL_DAIO_PORT_MASK_DIGITAL_D3 | XL_DAIO_PORT_MASK_DIGITAL_D4 | XL_DAIO_PORT_MASK_DIGITAL_D5 | XL_DAIO_PORT_MASK_DIGITAL_D6 | XL_DAIO_PORT_MASK_DIGITAL_D7;
		trigMode.param.digital.type = XL_DAIO_TRIGGER_TYPE_BOTH;

		xlStatus = xlIoSetTriggerMode(g_xlPortHandle, g_xlChannelMask, &trigMode);
		if (xlStatus != XL_SUCCESS)
		{
			printf("\nERROR: xlIoSetTriggerMode(on-edge) failed\n");
			return 0;
		}
	}

	// Activate Channel
	xlStatus = xlActivateChannel(g_xlPortHandle, g_xlChannelMask, XL_BUS_TYPE_DAIO, 0);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlActivateChannel failed!\n");
		return xlStatus;
	}
	printf(" >> Channel Activated.\n");

	// Start measurements
	xlStatus = xlIoStartSampling(g_xlPortHandle, g_xlChannelMask, XL_DAIO_PORT_TYPE_MASK_DIGITAL | XL_DAIO_PORT_TYPE_MASK_ANALOG);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoStartSampling failed!\n");
		return xlStatus;
	}
	printf(" >> Measurements started.\n");

	// IO-Piggy
	memset(&anaPar, 0x00, sizeof(anaPar));
	anaPar.portMask = XL_DAIO_PORT_MASK_ANALOG_A0;
	anaPar.value[0] = g_outputMilliVolt; //mV
	xlStatus = xlIoSetAnalogOutput(g_xlPortHandle, g_xlChannelMask, &anaPar);
	if (xlStatus != XL_SUCCESS)
	{
		printf("\nERROR: xlIoSetAnalogOutput failed\n");
		return xlStatus;
	}

	return xlStatus;
}

////////////////////////////////////////////////////////////////////////////

//! Toggle output

//!
//!
////////////////////////////////////////////////////////////////////////////
void ToogleSwitch()
{

	//closes/opens all relays at the same time
	g_switchState = ~g_switchState;

	// IO-Cab
	if (g_trcvType == XL_TRANSCEIVER_TYPE_DAIO_8444_OPTO)
	{
		if (xlDAIOSetDigitalOutput(g_xlPortHandle, g_xlChannelMask, SWITCH_DIO0_DIO01, g_switchState) != XL_SUCCESS)
		{
			printf("\nERROR: xlDAIOSetDigitalOutput failed\n");
		}
	}

	// IO-Piggy (fix or VN89..)
	if ((g_trcvType == XL_TRANSCEIVER_TYPE_PB_DAIO_8642) || (g_trcvType == XL_TRANSCEIVER_TYPE_DAIO_1021_FIX))
	{
		XLdaioDigitalParams digPar;
		memset(&digPar, 0x00, sizeof(digPar));
		digPar.portMask = XL_DAIO_PORT_MASK_DIGITAL_D0;
		digPar.valueMask = g_switchState;
		if (xlIoSetDigitalOutput(g_xlPortHandle, g_xlChannelMask, &digPar) != XL_SUCCESS)
		{
			printf("\nERROR: xlIoSetDigitalOutput(digIn) failed\n");
		}
	}
}

////////////////////////////////////////////////////////////////////////////

//! Close XLAPI

//!
//!
////////////////////////////////////////////////////////////////////////////

void CloseExample()
{

	// Close XL driver
	xlDeactivateChannel(g_xlPortHandle, g_xlChannelMask);
	xlClosePort(g_xlPortHandle);
	xlCloseDriver();
	printf("\n >> XL Driver Closed\n");

	// Close RX thread
	g_ThreadRun = 0;
	if (CloseHandle(g_Thread))
		printf(" >> RX Thread Closed.\n");
	else
		printf(" >> RX Thread NOT Closed!\n");
}

////////////////////////////////////////////////////////////////////////////

//! Measuring Thread

//!
//!
////////////////////////////////////////////////////////////////////////////

DWORD WINAPI RxThread(LPVOID par)
{

	XLstatus xlStatus;
	XLevent xlEvent;
	DWORD eventResult;
	unsigned int msgsrx;

	UNREFERENCED_PARAMETER(par);

	// RX Thread Loop
	while (g_ThreadRun)
	{
		// wait for RX message event
		eventResult = WaitForSingleObject(g_hMsgEvent, 10);
		if (eventResult == WAIT_OBJECT_0)
		{
			// init status
			xlStatus = XL_SUCCESS;

			// read hardware queue while not empty
			while (!xlStatus)
			{
				msgsrx = RECEIVE_EVENT_COUNT;
				xlStatus = xlReceive(g_xlPortHandle, &msgsrx, &xlEvent);

				if (xlStatus == XL_SUCCESS)
				{

					///////////////////////////////////////////
					// parse IOcab event
					if (xlEvent.tag == XL_RECEIVE_DAIO_DATA)
					{

						printf(" - Analog Port : AIO0  |  AIO1  |  AIO2  |  AIO3  \n");
						printf("                 %04dmV", xlEvent.tagData.daioData.value_analog[0]);
						printf("| %04dmV ", xlEvent.tagData.daioData.value_analog[1]);
						printf("| %04dmV ", xlEvent.tagData.daioData.value_analog[2]);
						printf("| %04dmV\n\n", xlEvent.tagData.daioData.value_analog[3]);

						switch (g_switchState)
						{
						case 0:
							printf(" - Switch      : OPEN\n");
							break;
						default:
							printf(" - Switch      : CLOSED\n");
							break;
						}

						printf(" - Digital Port: DIO7|DIO6|DIO5|DIO4|DIO3|DI2|DIO1|DIO0|(value)\n");
						printf("                    %x|   %x|   %x|   %x|   %x|  %x|   %x|   %x| (%x)\n\n",
							   (xlEvent.tagData.daioData.value_digital & 128) >> 7,
							   (xlEvent.tagData.daioData.value_digital & 64) >> 6,
							   (xlEvent.tagData.daioData.value_digital & 32) >> 5,
							   (xlEvent.tagData.daioData.value_digital & 16) >> 4,
							   (xlEvent.tagData.daioData.value_digital & 8) >> 3,
							   (xlEvent.tagData.daioData.value_digital & 4) >> 2,
							   (xlEvent.tagData.daioData.value_digital & 2) >> 1,
							   (xlEvent.tagData.daioData.value_digital & 1),
							   (xlEvent.tagData.daioData.value_digital));
					}

					///////////////////////////////////////////
					// parse IOPiggy event

					if (xlEvent.tag == XL_RECEIVE_DAIO_PIGGY)
					{
						// Events for IO-Piggy
						if (xlEvent.tagData.daioPiggyData.daioEvtTag == XL_DAIO_EVT_ID_ANALOG)
						{
							printf(" - Analog Port : AIO0  |  AIO1  |  AIO2  |  AIO3  \n");
							printf("                 %04dmV", xlEvent.tagData.daioPiggyData.data.analog.measuredAnalogData0);
							printf("| %04dmV ", xlEvent.tagData.daioPiggyData.data.analog.measuredAnalogData1);
							printf("| %04dmV ", xlEvent.tagData.daioPiggyData.data.analog.measuredAnalogData2);
							printf("| %04dmV\n\n", xlEvent.tagData.daioPiggyData.data.analog.measuredAnalogData3);
						}
					}
					if (xlEvent.tagData.daioPiggyData.daioEvtTag == XL_DAIO_EVT_ID_DIGITAL)
					{
						printf(" - Digital out : %s\n", (g_switchState > 0) ? "HIGH" : "LOW");

						printf(" - Digital Port: DIO7|DIO6|DIO5|DIO4|DIO3|DI2|DIO1|DIO0|(value)\n");
						printf("                   %x|   %x|   %x|   %x|   %x|  %x|   %x|   %x| (%x)\n\n",
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 128) >> 7,
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 64) >> 6,
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 32) >> 5,
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 16) >> 4,
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 8) >> 3,
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 4) >> 2,
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 2) >> 1,
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData & 1),
							   (xlEvent.tagData.daioPiggyData.data.digital.digitalInputData));
					}
				}
			}
		}
	}

	return NO_ERROR;
}

////////////////////////////////////////////////////////////////////////////

//! main

//!
//!
////////////////////////////////////////////////////////////////////////////

int main_xl(int argc, char *argv[])
{

	XLstatus xlStatus = XL_ERROR;
	//int c;
	//int stop = 0;

	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

	printf(drawLine);
	printf("                          xlDAIOexample                            \n");
	printf("                   Vector Informatik GmbH, " __DATE__ "             \n");
	printf(drawLine);

	// open driver, searching DAIO hardware
	xlStatus = daioInit();
	if (xlStatus)
	{
		//_getch();
		return (0);
	}

	// create a RX thread to receive messages
	//xlStatus = daioCreateRxThread();

	// check the kind of measurement
	printf("\n\n: Press <c>   for cyclic trigger");
	printf("\n: Press <e>   for on-edge digital trigger\n");


	printf(" >> Using on-edge trigger for digital inputs.\n");
	g_ioPiggyDigitalTriggerCyclic = 0;
	/*
	c = 'e';//_getch();
	if (c == 'e')
	{
		printf(" >> Using on-edge trigger for digital inputs.\n");
		g_ioPiggyDigitalTriggerCyclic = 0;
	}
	else
	{
		printf(" >> Using cyclic trigger for digital inputs.\n");
		g_ioPiggyDigitalTriggerCyclic = 1;
	}
	*/
	
	// setup the DAIO channel depending on the DAIO hardware
	if (g_trcvType == XL_TRANSCEIVER_TYPE_DAIO_8444_OPTO)
	{
		xlStatus = daioSetupCab();
	}
	else if (g_trcvType == XL_TRANSCEIVER_TYPE_PB_DAIO_8642)
	{
		xlStatus = daioSetupPiggy();
	}
	else if (g_trcvType == XL_TRANSCEIVER_TYPE_DAIO_1021_FIX)
	{
		xlStatus = daioSetupFixPiggy();
	}
	else
	{
		printf("ERROR! no DAIO trx support!\n");
		return (0);
	}

	if (xlStatus)
	{
		return (0);
	}

	printf("\n: Press <t>   for toggle analog output");
	printf("\n: Press <ESC> for exit\n\n");

	// ------------------------------------
	// parse the key - commands
	// ------------------------------------
/*
	while (stop == 0)
	{

		
		unsigned long n;
		INPUT_RECORD ir;

		ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE), &ir, 1, &n);

		if ((n == 1) && (ir.EventType == KEY_EVENT))
		{

			if (ir.Event.KeyEvent.bKeyDown)
			{

				c = ir.Event.KeyEvent.uChar.AsciiChar;
				switch (c)
				{

				case 't':
					ToogleSwitch();
					break;

				case 27: // end application
					stop = 1;
					break;

				default:
					break;
				}
			}
		}
	}
*/
	//CloseExample();
	//_getch();

	return 0;
}


// Main step function being executed every 5 ms
void step(void) { // interval = 5 ms

}

// On start handler "On_Start"
void on_start_On_Start(void) { // on start event

main_xl(0, NULL);
}

// On stop handler "On_Stop"
void on_stop_On_Stop(void) { // on stop event
CloseExample();

}

// On shortcut "On_ANYKEY" with shortcut = ANY
void on_shortcut_On_ANYKEY(const s32 AShortcut) { // on shortcut = ANY
c = AShortcut;

      printf("key pressed: %c", c);

		//app.wait(5, 0);
		switch (c)
		{

		case 't':                 
    case 'T':
			ToogleSwitch();

			break;

		case 27: // end application
			stop = 1;
			break;

		default:
			break;
		}
}

